# -*- coding: utf-8 -*-
"""p2p.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LbOPer05e94zBYEpwZVbP_befL1u30T6
"""

import sqlite3
import socket
import threading
import time
import argparse

# naming the database file
db_file = "p2pmessaging.db"

# creating a centralized server for P2P communication
class CentralizedServer:
  def __init__(self, ip, port):
    self.ip = ip
    self.port = port
    self.users = {} # dictionary to store the users
    self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    self.server_socket.bind((self.ip, self.port))
    self.db_connection = sqlite3.connect(db_file)
    self.create_tables()

  def create_db_connection(self):
    if not hasattr(self.local_data, "db_connection"):
      self.local_data.db_connection = sqlite3.connect(db_file)
      self.local_data.cursor = self.local_data.db_connection.cursor()


  def create_tables(self):
    # function that creates the table for the database
    cursor = self.db_connection.cursor()
    cursor.execute('''CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY,
      username TEXT,
      ip TEXT,
      port INTEGER
      )''')
    cursor.execute('''CREATE TABLE IF NOT EXISTS messages (
      id INTEGER PRIMARY KEY,
      sender TEXT,
      recipient TEXT,
      message TEXT,
      timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )''')
    self.db_connection.commit()

  def handle_client(self, client_socket, addr):
    db_connection = sqlite3.connect(db_file)
    username = client_socket.recv(1024).decode("utf-8")
    user_ip = addr[0]
    user_port = addr[1]
    self.users[username] = {"ip": user_ip, "port": user_port}
    db_connection.execute("INSERT INTO users (username, ip, port) VALUES (?, ?, ?)",
                           (username, user_ip, user_port))
    db_connection.commit()
    print(f"User '{username}' connected from {user_ip}:{user_port}")
    while True:
        try:
            message = client_socket.recv(1024).decode("utf-8")
            if message:
                parts = message.split(":")
                if len(parts) == 2:
                    recipient = parts[0].strip()
                    message_content = parts[1].strip()
                    recipient_info = self.users.get(recipient)
                    if recipient_info:
                        recipient_ip = recipient_info["ip"]
                        recipient_port = recipient_info["port"]
                        recipient_address = (recipient_ip, recipient_port)
                        with sqlite3.connect(db_file) as conn:
                            cursor = conn.cursor()
                            cursor.execute("INSERT INTO messages (sender, recipient, message) VALUES (?, ?, ?)",
                                           (username, recipient, message_content))
                            conn.commit()
                        print(f"Message sent from '{username}' to '{recipient}': {message_content}")
                        recipient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        recipient_socket.connect(recipient_address)
                        recipient_socket.send(f"{username}:{message_content}".encode("utf-8"))
                        recipient_socket.close()
                    else:
                        print(f"Error: Recipient '{recipient}' not found.")
                else:
                    print("Error: Invalid message format.")
        except Exception as e:
            print("Error:", e)
            break
    client_socket.close()
    db_connection.close()


  def start(self):
    self.server_socket.listen(5)
    print(f"Server started at {self.ip}:{self.port}")
    while True:
        client_socket, addr = self.server_socket.accept()
        client_thread = threading.Thread(target=self.handle_client, args=(client_socket, addr))
        client_thread.start()

class Client:
    def __init__(self, username, server_ip, server_port):
        self.username = username
        self.server_ip = server_ip
        self.server_port = server_port
        self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.client_socket.connect((self.server_ip, self.server_port))

    def send_message(self, recipient, message):
        self.client_socket.send(f"{recipient}: {message}".encode("utf-8"))

    def receive_messages(self):
        with sqlite3.connect(db_file) as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM messages WHERE recipient = ?", (self.username,))
            messages = cursor.fetchall()
            for msg in messages:
                print(f"Received message from '{msg[1]}': {msg[3]}")


# demonstrations
##if __name__ == "__main__":
##    # initializing the centralized server
##    server_ip = "127.0.0.1"
##    server_port = 12345
##    server = CentralizedServer(server_ip, server_port)
##    server_thread = threading.Thread(target=server.start)
##    server_thread.start()
##
##    # creating sample clients
##    client1 = Client("Avantika", server_ip, server_port)
##    client2 = Client("Sheila", server_ip, server_port)
##
##    # sending and receiving sample messages
##    client1.send_message("Sheila", "Hello, how are you today?")
##    time.sleep(1)  # Wait for the message to propagate
##    client2.receive_messages()
##    client2.send_message("Avantika", "I am good. How are you?")
##    time.sleep(1)
##    client1.receive_messages()
    

##    # closing client connections
##    client1.client_socket.close()
##    client2.client_socket.close()

def run_server(ip, port):
    server = CentralizedServer(ip, port)
    server.start()

def run_client(username, server_ip, server_port):
    client = Client(username, server_ip, server_port)
    
    # Start a separate thread to continuously receive messages
    receive_thread = threading.Thread(target=client.receive_messages)
    receive_thread.start()
    
    # Continuously prompt the user for messages to send
    while True:
        message_content = input("Enter message: ")
        if message_content.lower() == "/quit":
            client.send_message("Server", "/quit")  # Send special message to server
            break
        else:
            client.send_message(username, message_content)
    
    # Close the client socket
    client.client_socket.close()


def main():
    parser = argparse.ArgumentParser(description="Centralized messaging system")
    parser.add_argument("role", choices=["server", "client"], help="Choose 'server' or 'client'")
    parser.add_argument("--ip", default="127.0.0.1", help="IP address to bind/connect to")
    parser.add_argument("--port", type=int, default=12345, help="Port number to bind/connect to")
    parser.add_argument("--username", help="Username for the client")

    args = parser.parse_args()

    if args.role == "server":
        run_server(args.ip, args.port)
    elif args.role == "client":
        if not args.username:
            parser.error("You must provide a username for the client")
        run_client(args.username, args.ip, args.port)

if __name__ == "__main__":
    main()



